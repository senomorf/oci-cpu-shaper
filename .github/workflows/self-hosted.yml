name: Self-hosted Runner Validation

on:
  workflow_dispatch:
  schedule:
    - cron: "17 */6 * * *"

permissions:
  contents: read

jobs:
  validation:
    name: OCI self-hosted checks
    runs-on:
      - self-hosted
      - oci-free-tier
    timeout-minutes: 30
    env:
      OCI_CLI_AUTH: instance_principal
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5.0.0

      - name: Collect IMDS metadata
        id: imds
        run: |
          set -euo pipefail

          header="Authorization: Bearer Oracle"
          base_url="http://169.254.169.254/opc/v2"

          instance_json=$(curl -sS -H "$header" "$base_url/instance/")
          vnic_json=$(curl -sS -H "$header" "$base_url/vnics/0/")

          # echo "instance=$instance_json"
          # echo "vnic=$vnic_json"

          instance_id=$(echo "$instance_json" | jq -r '.id')
          compartment_id=$(echo "$instance_json" | jq -r '.compartmentId')
          canonical_region=$(echo "$instance_json" | jq -r '.canonicalRegionName // ""')
          fallback_region=$(echo "$instance_json" | jq -r '.regionInfo.regionIdentifier // ""')

          if [ -z "$instance_id" ] || [ "$instance_id" = "null" ]; then
            echo "::error::IMDS instance payload did not contain an id"
            exit 1
          fi

          if [ -z "$compartment_id" ] || [ "$compartment_id" = "null" ]; then
            echo "::error::IMDS instance payload did not contain a compartmentId"
            exit 1
          fi

          region="$canonical_region"
          if [ -z "$region" ] || [ "$region" = "null" ]; then
            region="$fallback_region"
          fi

          if [ -z "$region" ] || [ "$region" = "null" ]; then
            echo "::error::Unable to determine region from IMDS"
            exit 1
          fi

          {
            echo "instance-ocid=$instance_id"
            echo "compartment-ocid=$compartment_id"
            echo "region=$region"
          } >>"$GITHUB_OUTPUT"

      - name: Set up Go
        uses: actions/setup-go@v6.0.0
        with:
          go-version-file: go.mod
          cache: true

      - name: Verify Always Free guardrail alarm
        env:
          INSTANCE_OCID: ${{ steps.imds.outputs.instance-ocid }}
          COMPARTMENT_OCID: ${{ steps.imds.outputs.compartment-ocid }}
          OCI_REGION: ${{ steps.imds.outputs.region }}
          METRIC_COMPARTMENT_OCID: ${{ vars.SELF_HOSTED_METRIC_COMPARTMENT_OCID || '' }}
          SKIP_GUARD: ${{ vars.SELF_HOSTED_SKIP_ALARM_GUARD || 'false' }}
          REQUIRE_DESTINATIONS: ${{ vars.SELF_HOSTED_REQUIRE_ALARM_DESTINATIONS || 'true' }}
          EXPECTED_PENDING: ${{ vars.SELF_HOSTED_EXPECTED_PENDING_DURATION || 'PT1H' }}
          EXPECTED_RESOLUTION: ${{ vars.SELF_HOSTED_EXPECTED_RESOLUTION || '1d' }}
        run: |
          set -euo pipefail

          if [ "${SKIP_GUARD,,}" = "true" ]; then
            echo "Skipping Always Free guardrail verification"
            exit 0
          fi

          if [ -z "$INSTANCE_OCID" ] || [ -z "$COMPARTMENT_OCID" ]; then
            echo "::error::Missing instance or compartment identifiers for guardrail validation"
            exit 1
          fi

          args=(
            -instance "$INSTANCE_OCID"
            -compartment "$COMPARTMENT_OCID"
            -region "$OCI_REGION"
            -timeout 60s
            -expected-pending "$EXPECTED_PENDING"
            -expected-resolution "$EXPECTED_RESOLUTION"
          )

          if [ -n "$METRIC_COMPARTMENT_OCID" ]; then
            args+=( -metric-compartment "$METRIC_COMPARTMENT_OCID" )
          fi

          if [ "${REQUIRE_DESTINATIONS,,}" != "true" ]; then
            args+=( -require-destinations=false )
          fi

          go run ./hack/tools/alarmguard "${args[@]}"

      - name: Query Monitoring for P95 CPU
        env:
          INSTANCE_OCID: ${{ steps.imds.outputs.instance-ocid }}
          COMPARTMENT_OCID: ${{ steps.imds.outputs.compartment-ocid }}
          OCI_REGION: ${{ steps.imds.outputs.region }}
          ALLOW_EMPTY: ${{ vars.SELF_HOSTED_ALLOW_EMPTY_METRICS || 'false' }}
        run: |
          set -euo pipefail

          if [ -z "$INSTANCE_OCID" ] || [ -z "$COMPARTMENT_OCID" ]; then
            echo "::error::Missing instance or compartment identifiers"
            exit 1
          fi

          args=(
            -instance "$INSTANCE_OCID"
            -compartment "$COMPARTMENT_OCID"
            -region "$OCI_REGION"
            -timeout 45s
          )

          if [ "$ALLOW_EMPTY" = "true" ]; then
            args+=( -allow-empty )
          fi

          go run ./hack/tools/p95query "${args[@]}"

      - name: Validate Docker cgroup v2 behaviour
        run: |
          set -euo pipefail

          version=$(docker info --format '{{.CgroupVersion}}')
          echo "Detected cgroup version: $version"
          if [ "$version" != "2" ]; then
            echo "::error::Expected Docker to run with cgroup v2"
            exit 1
          fi

          docker pull --quiet alpine:3.20
          docker run --rm alpine:3.20 sh -c 'cat /sys/fs/cgroup/cgroup.controllers'
          docker run --rm --cpus=0.5 alpine:3.20 sh -c "echo cpu.max=\$(cat /sys/fs/cgroup/cpu.max) cpu.weight=\$(cat /sys/fs/cgroup/cpu.weight)"

      - name: Build rootful integration image
        run: |
          set -euo pipefail

          docker build \
            --target rootful \
            -t oci-cpu-shaper:integration-rootful \
            -f deploy/Dockerfile \
            .

      - name: Exercise CPU weight containers and collect cgroup stats
        env:
          LOG_ROOT: ${{ github.workspace }}/artifacts/self-hosted-cgroup
        run: |
          set -euo pipefail

          mkdir -p "$LOG_ROOT"
          run_dir="$LOG_ROOT/run-$(date --utc +%Y%m%dT%H%M%SZ)"
          mkdir -p "$run_dir"

          tmpdir=$(mktemp -d)
          hog_binary="$tmpdir/cpu-hog"
          high_name=""
          low_name=""

          cleanup() {
            status=$?
            set +e
            for name in "$high_name" "$low_name"; do
              if [ -n "$name" ]; then
                docker logs "$name" >"$run_dir/${name}.log" 2>&1 || true
                docker rm -f "$name" >/dev/null 2>&1 || true
              fi
            done
            rm -rf "$tmpdir"
            exit $status
          }
          trap cleanup EXIT

          echo "Building cpu-hog helper"
          GOARCH=$(go env GOARCH)
          CGO_ENABLED=0 GOOS=linux GOARCH="$GOARCH" go build -o "$hog_binary" ./tests/integration/cmd/cpu-hog

          high_name="cpu-weight-high-$(date +%s%N)"
          low_name="cpu-weight-low-$(date +%s%N)"

          echo "Launching high weight container: $high_name"
          docker run \
            --detach \
            --name "$high_name" \
            --cpuset-cpus=0 \
            --cpu-shares 1024 \
            -v "$hog_binary:/hog:Z,ro" \
            --entrypoint /hog \
            alpine:3.20 \
            -duration=40s \
            -workers=1

          echo "Launching low weight container: $low_name"
          docker run \
            --detach \
            --name "$low_name" \
            --cpuset-cpus=0 \
            --cpu-shares 2 \
            -v "$hog_binary:/hog:Z,ro" \
            --entrypoint /hog \
            oci-cpu-shaper:integration-rootful \
            -duration=40s \
            -workers=1

          wait_for_running() {
            local name=$1
            local deadline=$((SECONDS + 45))
            while [ $SECONDS -lt $deadline ]; do
              if [ "$(docker inspect -f '{{.State.Running}}' "$name" 2>/dev/null || echo false)" = "true" ]; then
                return 0
              fi
              sleep 1
            done
            echo "::error::container $name did not reach running state" >&2
            docker ps -a >&2 || true
            return 1
          }

          wait_for_running "$high_name"
          wait_for_running "$low_name"

          echo "Allowing workloads to collect CPU usage"
          sleep 30

          record_stats() {
            local name=$1
            local pid
            pid=$(docker inspect -f '{{.State.Pid}}' "$name")
            if [ -z "$pid" ] || [ "$pid" = "0" ]; then
              echo "::error::container $name reported invalid pid: $pid" >&2
              return 1
            fi

            local rel_path
            rel_path=$(awk -F: '$1=="0" {print $3}' "/proc/$pid/cgroup")
            if [ -z "$rel_path" ]; then
              echo "::error::unable to resolve cgroup path for $name (pid $pid)" >&2
              return 1
            fi

            local cg_path="/sys/fs/cgroup${rel_path}"
            if [ ! -d "$cg_path" ]; then
              echo "::error::cgroup path $cg_path missing for $name" >&2
              return 1
            fi

            cat "$cg_path/cpu.stat" >"$run_dir/${name}-cpu.stat"
            cat "$cg_path/cpu.weight" >"$run_dir/${name}-cpu.weight"
            if [ -f "$cg_path/cpu.max" ]; then
              cat "$cg_path/cpu.max" >"$run_dir/${name}-cpu.max"
            fi
            printf '%s %s\n' "$name" "$cg_path" >>"$run_dir/cgroup-paths.txt"
          }

          record_stats "$high_name"
          record_stats "$low_name"

          parse_usage() {
            awk '/usage_usec/ {print $2; exit}' "$run_dir/$1-cpu.stat"
          }

          parse_weight() {
            tr -d '\n' <"$run_dir/$1-cpu.weight"
          }

          high_usage=$(parse_usage "$high_name")
          low_usage=$(parse_usage "$low_name")
          high_weight=$(parse_weight "$high_name")
          low_weight=$(parse_weight "$low_name")

          echo "High weight usage (µs): $high_usage (weight=$high_weight)" | tee "$run_dir/${high_name}-summary.txt"
          echo "Low weight usage (µs): $low_usage (weight=$low_weight)" | tee "$run_dir/${low_name}-summary.txt"

          if [ -z "$high_weight" ] || [ -z "$low_weight" ]; then
            echo "::error::missing cpu.weight data" >&2
            exit 1
          fi

          if [ "$high_weight" -le "$low_weight" ]; then
            echo "::error::expected high weight container to exceed low weight" >&2
            exit 1
          fi

          if [ -z "$high_usage" ] || [ -z "$low_usage" ] || [ "$low_usage" = "0" ]; then
            echo "::error::missing cpu usage data" >&2
            exit 1
          fi

          python_script=$'import decimal\n'
          python_script+=$'import sys\n\n'
          python_script+=$'high = decimal.Decimal(sys.argv[1])\n'
          python_script+=$'low = decimal.Decimal(sys.argv[2])\n'
          python_script+=$'ratio = high / low\n\n'
          python_script+=$'if ratio < decimal.Decimal("5.0"):\n'
          python_script+=$'    sys.stderr.write("::error::expected high weight container to receive at least 5.0x CPU time (got {:.2f}x)\\n".format(ratio))\n'
          python_script+=$'    sys.exit(1)\n\n'
          python_script+=$'print(ratio.quantize(decimal.Decimal("0.01")))\n'
          ratio=$(python -c "$python_script" "$high_usage" "$low_usage")
          echo "Observed CPU usage ratio (high/low): $ratio" | tee "$run_dir/ratio.txt"
          echo "CPU weight responsiveness verified"

      - name: Upload self-hosted cgroup artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: self-hosted-cgroup-data
          path: artifacts/self-hosted-cgroup
          retention-days: 7
